.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Font::TTF::OS_2 3"
.TH Font::TTF::OS_2 3 "2016-08-03" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Font::TTF::OS_2 \- the OS/2 table in a TTF font
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \s-1OS/2\s0 table has two versions and forms, one an extension of the other. This
module supports both forms and the switching between them.
.SH "INSTANCE VARIABLES"
.IX Header "INSTANCE VARIABLES"
No other variables than those in table and those in the standard:
.PP
.Vb 10
\&    Version
\&    xAvgCharWidth
\&    usWeightClass
\&    usWidthClass
\&    fsType
\&    ySubscriptXSize
\&    ySubScriptYSize
\&    ySubscriptXOffset
\&    ySubscriptYOffset
\&    ySuperscriptXSize
\&    ySuperscriptYSize
\&    ySuperscriptXOffset
\&    ySuperscriptYOffset
\&    yStrikeoutSize
\&    yStrikeoutPosition
\&    sFamilyClass
\&    bFamilyType
\&    bSerifStyle
\&    bWeight
\&    bProportion
\&    bContrast
\&    bStrokeVariation
\&    bArmStyle
\&    bLetterform
\&    bMidline
\&    bXheight
\&    ulUnicodeRange1
\&    ulUnicodeRange2
\&    ulUnicodeRange3
\&    ulUnicodeRange4
\&    achVendID
\&    fsSelection
\&    usFirstCharIndex
\&    usLastCharIndex
\&    sTypoAscender
\&    sTypoDescender
\&    sTypoLineGap
\&    usWinAscent
\&    usWinDescent
\&    ulCodePageRange1
\&    ulCodePageRange2
\&    xHeight
\&    CapHeight
\&    defaultChar
\&    breakChar
\&    maxLookups
.Ve
.PP
Notice that versions 0, 1, 2 & 3 of the table are supported. Notice also that the
Panose variable has been broken down into its elements.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$t\->read"
.el .SS "\f(CW$t\fP\->read"
.IX Subsection "$t->read"
Reads in the various values from disk (see details of \s-1OS/2\s0 table)
.ie n .SS "$t\->out($fh)"
.el .SS "\f(CW$t\fP\->out($fh)"
.IX Subsection "$t->out($fh)"
Writes the table to a file either from memory or by copying.
.ie n .SS "$t\->XML_element($context, $depth, $key, $value)"
.el .SS "\f(CW$t\fP\->XML_element($context, \f(CW$depth\fP, \f(CW$key\fP, \f(CW$value\fP)"
.IX Subsection "$t->XML_element($context, $depth, $key, $value)"
Tidies up the hex values to output them in hex
.ie n .SS "$t\->XML_end($context, $tag, %attrs)"
.el .SS "\f(CW$t\fP\->XML_end($context, \f(CW$tag\fP, \f(CW%attrs\fP)"
.IX Subsection "$t->XML_end($context, $tag, %attrs)"
Now handle them on the way back in
.ie n .SS "$t\->\fIminsize()\fP"
.el .SS "\f(CW$t\fP\->\fIminsize()\fP"
.IX Subsection "$t->minsize()"
Returns the minimum size this table can be. If it is smaller than this, then the table
must be bad and should be deleted or whatever.
.ie n .SS "$t\->update"
.el .SS "\f(CW$t\fP\->update"
.IX Subsection "$t->update"
Updates the \s-1OS/2\s0 table by getting information from other sources:
.PP
Updates the \f(CW\*(C`firstChar\*(C'\fR and \f(CW\*(C`lastChar\*(C'\fR values based on the \s-1MS\s0 table in the
cmap.
.PP
Updates the sTypoAscender, sTypoDescender & sTypoLineGap to be the same values
as Ascender, Descender and Linegap from the hhea table (assuming it is dirty)
and also sets usWinAscent to be the sum of Ascender+Linegap and usWinDescent to
be the negative of Descender.
.ie n .SS "$t\->guessRangeBits (\e%map, [$cp_threshold, [%u_threshold]])"
.el .SS "\f(CW$t\fP\->guessRangeBits (\e%map, [$cp_threshold, [%u_threshold]])"
.IX Subsection "$t->guessRangeBits (%map, [$cp_threshold, [%u_threshold]])"
Set the ulCodePageRange and ulUnicodeRange fields based on characters actually present in the font.
.PP
\&\f(CW%map\fR is a hash keyed by \s-1USV\s0 returning non-zero for characters present (e.g. use {'val'} 
a from Unicode cmap).
.PP
The two optional parameters are percentage of characters within the codepage or unicode range that need
to be present to constitute coverage. A threshold of 0 causes corresponding range bits to 
be set if any characters are present at all, while a negative value causes the corresponding
range bits to be unchanged. Defaults are 50 and 0, respectively.
.PP
For codepage bits, the threshold is percentage of characters between 0xC0 and 0xFF that need
to be present to constitute coverage). For codepages other than 1252, 
characters (e.g., punctuation) that are defined identically to cp1252 are ignored
for the purposes of this percentage calculation. Looks only for \s-1SBCS\s0 codepages, not \s-1DBCS.\s0
.PP
For Unicode range bits that represent multiple ranges, e.g., bit 29 represents:
.PP
.Vb 3
\&  Latin Extended Additional  1E00\-1EFF
\&  Latin Extended\-C           2C60\-2C7F
\&  Latin Extended\-D           A720\-A7FF
.Ve
.PP
the bit will be set if any of these ranges meet the threshold requirement.
.SH "BUGS"
.IX Header "BUGS"
None known
.SH "AUTHOR"
.IX Header "AUTHOR"
Martin Hosken <http://scripts.sil.org/FontUtils>.
.SH "LICENSING"
.IX Header "LICENSING"
Copyright (c) 1998\-2016, \s-1SIL\s0 International (http://www.sil.org)
.PP
This module is released under the terms of the Artistic License 2.0. 
For details, see the full text of the license in the file \s-1LICENSE.\s0
