.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::Run::StandAloneBlastPlus 3"
.TH Bio::Tools::Run::StandAloneBlastPlus 3 "2018-08-09" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Tools::Run::StandAloneBlastPlus \- Compute with NCBI's blast+ suite *ALPHA*
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fB\s-1NOTE\s0\fR: This module is related to the
Bio::Tools::Run::StandAloneBlast system in name (and inspiration)
only. You must use this module directly.
.PP
.Vb 4
\& # existing blastdb:
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&   \-db_name => \*(Aqmydb\*(Aq
\& );
\& 
\& # create blastdb from fasta file and attach
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&   \-db_name => \*(Aqmydb\*(Aq,
\&   \-db_data => \*(Aqmyseqs.fas\*(Aq,
\&   \-create => 1
\& );
\& 
\& # create blastdb from BioPerl sequence collection objects
\& $alnio = Bio::AlignIO\->new( \-file => \*(Aqalignment.msf\*(Aq );
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&   \-db_name => \*(Aqmydb\*(Aq,
\&   \-db_data => $alnio,
\&   \-create => 1
\& );
\&
\& @seqs = $alnio\->next_aln\->each_seq;
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&   \-db_name => \*(Aqmydb\*(Aq,
\&   \-db_data => \e@seqs,
\&   \-create => 1
\& );
\&
\& # create database with masks
\&
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&  \-db_name => \*(Aqmy_masked_db\*(Aq,
\&  \-db_data => \*(Aqmyseqs.fas\*(Aq,
\&  \-masker => \*(Aqdustmasker\*(Aq,
\&  \-mask_data => \*(Aqmaskseqs.fas\*(Aq,
\&  \-create => 1
\& );
\&
\& # create a mask datafile separately
\& $mask_file = $fac\->make_mask(
\&   \-data => \*(Aqmaskseqs.fas\*(Aq,
\&   \-masker => \*(Aqdustmasker\*(Aq
\& );
\&
\& # query database for metadata
\& $info_hash = $fac\->db_info;
\& $num_seq = $fac\->db_num_sequences;
\& @mask_metadata = @{ $fac\->db_filter_algorithms };
\&
\& # perform blast methods
\& $result = $fac\->tblastn( \-query => $seqio );
\& # see Bio::Tools::Run::StandAloneBlastPlus::BlastMethods 
\& # for many more details
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1NOTE:\s0\fR This module requires \s-1BLAST+\s0 v. 2.2.24+ and higher.  Until the \s-1API\s0
stabilizes for \s-1BLAST+,\s0 consider this module highly experimental.
.PP
This module along with
Bio::Tools::Run::StandAloneBlastPlus::BlastMethods allows the user
to perform \s-1BLAST\s0 functions using the external program suite \f(CW\*(C`blast+\*(C'\fR
(available at
<ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST/>), using
BioPerl objects and Bio::SearchIO facilities. This wrapper can
prepare \s-1BLAST\s0 databases as well as run \s-1BLAST\s0 searches. It can also be
used to run \f(CW\*(C`blast+\*(C'\fR programs independently.
.PP
This module encapsulates object construction and production of
databases and masks. Blast analysis methods (\f(CW\*(C`blastp, psiblast\*(C'\fR,
etc>) are contained in
Bio::Tools::Run::StandAloneBlastPlus::BlastMethods.
.SH "USAGE"
.IX Header "USAGE"
The basic mantra is to (1) create a BlastPlus factory using the
\&\f(CW\*(C`new()\*(C'\fR constructor, and (2) perform \s-1BLAST\s0 analyses by calling the
desired \s-1BLAST\s0 program by name off the factory object. The blast
database itself and any masking data are attached to the factory
object (step 1). Query sequences and any parameters associated with
particular programs are provided to the blast method call (step 2),
and are run against the attached database.
.SS "Factory construction/initialization"
.IX Subsection "Factory construction/initialization"
The factory needs to be told where the blast+ programs live. The
\&\f(CW\*(C`BLASTPLUSDIR\*(C'\fR environment variable will be checked for the default
executable directory.  The program directory can be set for individual
factory instances with the \f(CW\*(C`PROG_DIR\*(C'\fR parameter. All the blast+
programs must be accessible from that directory (i.e., as executable
files or symlinks).
.PP
Either the database or \s-1BLAST\s0 subject data must be specified at object
construction. Databases can be pre-existing formatted \s-1BLAST\s0 dbs, or
can be built directly from fasta sequence files or BioPerl sequence
object collections of several kinds. The key constructor parameters
are \f(CW\*(C`DB_NAME\*(C'\fR, \f(CW\*(C`DB_DATA\*(C'\fR, \f(CW\*(C`DB_DIR\*(C'\fR.
.PP
To specify a pre-existing \s-1BLAST\s0 database, use \f(CW\*(C`DB_NAME\*(C'\fR alone:
.PP
.Vb 3
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&     \-DB_NAME => \*(Aqmydb\*(Aq
\& );
.Ve
.PP
The directory can be specified along with the basename, or separately
with \f(CW\*(C`DB_DIR\*(C'\fR:
.PP
.Vb 3
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&     \-DB_NAME => \*(Aq~/home/blast/mydb\*(Aq
\& );
\&
\& #same as
\&
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&     \-DB_NAME => \*(Aqmydb\*(Aq, \-DB_DIR => \*(Aq~/home/blast\*(Aq
\& );
.Ve
.PP
To create a \s-1BLAST\s0 database de novo, see \*(L"Creating a \s-1BLAST\s0 database\*(R".
.PP
If you wish to apply pre-existing mask data (i.e., the final \s-1ASN1\s0
output from one of the blast+ masker programs), to the database before
querying, specify it with \f(CW\*(C`MASK_FILE\*(C'\fR:
.PP
.Vb 3
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&     \-DB_NAME => \*(Aqmydb\*(Aq, \-MASK_FILE => \*(Aqmymaskdata.asn\*(Aq
\& );
.Ve
.SS "Creating a \s-1BLAST\s0 database"
.IX Subsection "Creating a BLAST database"
There are several options for creating the database de novo using
attached data, both before and after factory construction. If a
temporary database (one that can be deleted by the \f(CW\*(C`cleanup()\*(C'\fR
method) is desired, leave out the \f(CW\*(C`\-db_name\*(C'\fR parameter. If
\&\f(CW\*(C`\-db_name\*(C'\fR is specified, the database will be preserved with the
basename specified.
.PP
Use \f(CW\*(C`\-create =\*(C'\fR 1> to create a new database (otherwise the factory
will look for an existing database). Use \f(CW\*(C`\-overwrite =\*(C'\fR 1> to create
and overwrite an existing database.
.PP
Note that the database is not created immediately on factory
construction. It will be created if necessary on the first use of a
factory \s-1BLAST\s0 method, or you can force database creation by executing
.PP
.Vb 1
\& $fac\->make_db();
.Ve
.IP "\(bu" 4
Specify data during construction
.Sp
With a \s-1FASTA\s0 file:
.Sp
.Vb 5
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&   \-db_name => \*(Aqmydb\*(Aq,
\&   \-db_data => \*(Aqmyseqs.fas\*(Aq,
\&   \-create => 1
\& );
.Ve
.Sp
With another BioPerl object collection:
.Sp
.Vb 12
\& $alnio = Bio::AlignIO\->new( \-file => \*(Aqalignment.msf\*(Aq );
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&   \-db_name => \*(Aqmydb\*(Aq,
\&   \-db_data => $alnio,
\&   \-create => 1
\& );
\& @seqs = $alnio\->next_aln\->each_seq;
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&   \-db_name => \*(Aqmydb\*(Aq,
\&   \-db_data => \e@seqs,
\&   \-create => 1
\& );
.Ve
.Sp
Other collections (e.g., Bio::SeqIO) are valid. If a certain type
does not work, please submit an enhancement request.
.Sp
To create temporary databases, leave out the \f(CW\*(C`\-db_name\*(C'\fR, e.g.
.Sp
.Vb 4
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&   \-db_data => \*(Aqmyseqs.fas\*(Aq,
\&   \-create => 1
\& );
.Ve
.Sp
To get the tempfile basename, do:
.Sp
.Vb 1
\& $dbname = $fac\->db;
.Ve
.IP "\(bu" 4
Specify data post-construction
.Sp
Use the explicit attribute setters:
.Sp
.Vb 3
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&   \-create => 1
\& );
\&
\& $fac\->set_db_data(\*(Aqmyseqs.fas\*(Aq);
\& $fac\->make_db;
.Ve
.SS "Creating and using mask data"
.IX Subsection "Creating and using mask data"
The blast+ mask utilities \f(CW\*(C`windowmasker\*(C'\fR, \f(CW\*(C`segmasker\*(C'\fR, and
\&\f(CW\*(C`dustmasker\*(C'\fR are available. Masking can be rolled into database
creation, or can be executed later. If your mask data is already
created and in \s-1ASN1\s0 format, set the \f(CW\*(C`\-mask_file\*(C'\fR attribute on
construction (see \*(L"Factory constuction/initialization\*(R").
.PP
To create a mask from raw data or an existing database and apply the
mask upon database creation, construct the factory like so:
.PP
.Vb 7
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&   \-db_name => \*(Aqmy_masked_db\*(Aq,
\&   \-db_data => \*(Aqmyseqs.fas\*(Aq,
\&   \-masker => \*(Aqdustmasker\*(Aq,
\&   \-mask_data => \*(Aqmaskseqs.fas\*(Aq,
\&   \-create => 1
\& );
.Ve
.PP
The masked database will be created during \f(CW\*(C`make_db\*(C'\fR.
.PP
The \f(CW\*(C`\-mask_data\*(C'\fR parameter can be a \s-1FASTA\s0 filename or any BioPerl
sequence object collection. If the datatype ('nucl' or 'prot') of the
mask data is not compatible with the selected masker, an exception
will be thrown with a message to that effect.
.PP
To create a mask \s-1ASN1\s0 file that can be used in the \f(CW\*(C`\-mask_file\*(C'\fR
parameter separately from the attached database, use the
\&\f(CW\*(C`make_mask()\*(C'\fR method directly:
.PP
.Vb 5
\& $mask_file = $fac\->make_mask(\-data => \*(Aqmaskseqs.fas\*(Aq,
\&                              \-masker => \*(Aqdustmasker\*(Aq);
\& # segmasker can use a blastdb as input
\& $mask_file = $fac\->make_mask(\-mask_db => \*(Aqmydb\*(Aq,
\&                              \-masker => \*(Aqsegmasker\*(Aq)
\&
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&   \-db_name => \*(Aqmy_masked_db\*(Aq,
\&   \-db_data => \*(Aqmyseqs.fas\*(Aq,
\&   \-mask_file => $mask_file
\&   \-create => 1
\& );
.Ve
.SS "Getting database information"
.IX Subsection "Getting database information"
To get a hash containing useful metadata on an existing database
(obtained by running \f(CW\*(C`blastdbcmd \-info\*(C'\fR, use \f(CW\*(C`db_info()\*(C'\fR:
.PP
.Vb 4
\& # get info on the attached database..
\& $info = $fac\->db_info;
\& # get info on another database
\& $info = $fac\->db_info(\*(Aq~/home/blastdbs/another\*(Aq);
.Ve
.PP
To get a particular info element for the attached database, just call
the element name off the factory:
.PP
.Vb 3
\& $num_seqs = $fac\->db_num_sequences;
\& # info on all the masks applied to the db, if any:
\& @masking_info = @{ $fac\->db_filter_algorithms };
.Ve
.SS "Accessing the Bio::Tools::Run::BlastPlus factory"
.IX Subsection "Accessing the Bio::Tools::Run::BlastPlus factory"
The blast+ programs are actually executed by a
Bio::Tools::Run::BlastPlus wrapper instance. This instance is
available for peeking and poking in the StandAloneBlastPlus
\&\f(CW\*(C`factory()\*(C'\fR attribute. For convenience, \f(CW\*(C`BlastPlus\*(C'\fR methods can be
run from the \f(CW\*(C`StandAloneBlastPlus\*(C'\fR object, and are delegated to the
\&\f(CW\*(C`factory()\*(C'\fR attribute. For example, to get the blast+ program to be
executed, examine either
.PP
.Vb 1
\& $fac\->factory\->command
.Ve
.PP
or
.PP
.Vb 1
\& $fac\->command
.Ve
.PP
Similarly, the current parameters for the \f(CW\*(C`BlastPlus\*(C'\fR factory are
.PP
.Vb 1
\& @parameters = $fac\->get_parameters
.Ve
.SS "Cleaning up temp files"
.IX Subsection "Cleaning up temp files"
Temporary analysis files produced under a single factory instances can
be unlinked by running
.PP
.Vb 1
\& $fac\->cleanup;
.Ve
.PP
Tempfiles are generally not removed unless this method is explicitly
called. \f(CW\*(C`cleanup()\*(C'\fR only unlinks \*(L"registered\*(R" files and
databases. All temporary files are automatically registered; in
particular, \*(L"anonymous\*(R" databases (such as
.PP
.Vb 4
\& $fac\->Bio::Tools::Run::StandAloneBlastPlus\->new(
\&   \-db_data => \*(Aqmyseqs.fas\*(Aq, 
\&   \-create => 1
\& );
.Ve
.PP
without a \f(CW\*(C`\-db_name\*(C'\fR specification) are registered for cleanup. Any
file or database can be registered with an internal method:
.PP
.Vb 1
\& $fac\->_register_temp_for_cleanup(\*(Aqtestdb\*(Aq);
.Ve
.SS "Other Goodies"
.IX Subsection "Other Goodies"
.IP "\(bu" 4
You can check whether a given basename points to a properly formatted
\&\s-1BLAST\s0 database by doing
.Sp
.Vb 1
\& $is_good = $fac\->check_db(\*(Aqputative_db\*(Aq);
.Ve
.IP "\(bu" 4
User parameters can be passed to the underlying blast+ programs (if
you know what you're doing) with \f(CW\*(C`db_make_args\*(C'\fR and \f(CW\*(C`mask_make_args\*(C'\fR:
.Sp
.Vb 9
\& $fac = Bio::Tools::Run::StandAloneBlastPlus\->new(
\&   \-db_name => \*(Aqcustomdb\*(Aq,
\&   \-db_data => \*(Aqmyseqs.fas\*(Aq, 
\&   \-db_make_args => [ \*(Aq\-taxid_map\*(Aq => \*(Aqseq_to_taxa.txt\*(Aq ],
\&   \-masker => \*(Aqwindowmasker\*(Aq,
\&   \-mask_data => \*(Aqmyseqs.fas\*(Aq,
\&   \-mask_make_args => [ \*(Aq\-dust\*(Aq => \*(AqT\*(Aq ],
\&   \-create => 1
\& );
.Ve
.IP "\(bu" 4
You can prevent exceptions from being thrown by failed blast+ program
executions by setting \f(CW\*(C`no_throw_on_crash\*(C'\fR. Examine the error with
\&\f(CW\*(C`stderr()\*(C'\fR:
.Sp
.Vb 6
\& $fac\->no_throw_on_crash(1);
\& $fac\->make_db;
\& if ($fac\->stderr =~ /Error:/) {
\&    #handle error
\&    ...
\& }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::Tools::Run::StandAloneBlastPlus::BlastMethods,
Bio::Tools::Run::BlastPlus
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
bioperl\-l@bioperl.org
.PP
rather than to the module maintainer directly. Many experienced and
reponsive experts will be able look at the problem and quickly
address it. Please include a thorough description of the problem
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via
the web:
.PP
.Vb 1
\&  http://redmine.open\-bio.org/projects/bioperl/
.Ve
.SH "AUTHOR \- Mark A. Jensen"
.IX Header "AUTHOR - Mark A. Jensen"
Email maj \-at\- fortinbras \-dot\- us
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 6
\& Title   : new
\& Usage   : my $obj = new Bio::Tools::Run::StandAloneBlastPlus();
\& Function: Builds a new Bio::Tools::Run::StandAloneBlastPlus object
\& Returns : an instance of Bio::Tools::Run::StandAloneBlastPlus
\& Args    : named argument (key => value) pairs:
\&           \-db : blastdb name
.Ve
.SS "\fIdb()\fP"
.IX Subsection "db()"
.Vb 6
\& Title   : db
\& Usage   : $obj\->db($newval)
\& Function: contains the basename of the local blast database
\& Example : 
\& Returns : value of db (a scalar string)
\& Args    : readonly
.Ve
.SS "\fIfactory()\fP"
.IX Subsection "factory()"
.Vb 7
\& Title   : factory
\& Usage   : $obj\->factory($newval)
\& Function: attribute containing the Bio::Tools::Run::BlastPlus 
\&           factory
\& Example : 
\& Returns : value of factory (Bio::Tools::Run::BlastPlus object)
\& Args    : readonly
.Ve
.SS "\fIprogram_version()\fP"
.IX Subsection "program_version()"
.Vb 7
\& Title   : program_version
\& Usage   : $version = $bedtools_fac\->program_version()
\& Function: Returns the program version (if available)
\& Returns : string representing location and version of the program
\& Note    : this works around the WrapperBase::version() method conflicting with
\&           the \-version parameter for SABlast (good argument for not having
\&           getter/setters for these)
.Ve
.SS "\fIpackage_version()\fP"
.IX Subsection "package_version()"
.Vb 4
\& Title   : package_version
\& Usage   : $version = $bedtools_fac\->package_version()
\& Function: Returns the BLAST+ package version (if available)
\& Returns : string representing BLAST+ package version (may differ from version())
.Ve
.SH "DB methods"
.IX Header "DB methods"
.SS "\fImake_db()\fP"
.IX Subsection "make_db()"
.Vb 6
\& Title   : make_db
\& Usage   : 
\& Function: create the blast database (if necessary), 
\&           imposing masking if specified
\& Returns : true on success
\& Args    :
.Ve
.SS "\fImake_mask()\fP"
.IX Subsection "make_mask()"
.Vb 5
\& Title   : make_mask
\& Usage   : 
\& Function: create masking data based on specified parameters
\& Returns : mask data filename (scalar string)
\& Args    :
.Ve
.SS "\fIdb_info()\fP"
.IX Subsection "db_info()"
.Vb 6
\& Title   : db_info
\& Usage   : 
\& Function: get info for database 
\&           (via blastdbcmd \-info); add factory attributes
\& Returns : hash of database attributes
\& Args    : [optional] db name (scalar string) (default: currently attached db)
.Ve
.SS "\fIset_db_make_args()\fP"
.IX Subsection "set_db_make_args()"
.Vb 6
\& Title   : set_db_make_args
\& Usage   : 
\& Function: set the DB make arguments attribute 
\&           with checking
\& Returns : true on success
\& Args    : arrayref or hashref of named arguments
.Ve
.SS "\fIset_mask_make_args()\fP"
.IX Subsection "set_mask_make_args()"
.Vb 6
\& Title   : set_mask_make_args
\& Usage   : 
\& Function: set the masker make arguments attribute
\&           with checking
\& Returns : true on success
\& Args    : arrayref or hasref of named arguments
.Ve
.SS "\fIcheck_db()\fP"
.IX Subsection "check_db()"
.Vb 9
\& Title   : check_db
\& Usage   : 
\& Function: determine if database with registered name and dir
\&           exists
\& Returns : 1 if db present, 0 if not present, undef if name/dir not
\&           set
\& Args    : [optional] db name (default is \*(Aqregistered\*(Aq name in $self\->db)
\&           [optional] db directory (default is \*(Aqregistered\*(Aq dir in 
\&                                    $self\->db_dir)
.Ve
.SS "\fIno_throw_on_crash()\fP"
.IX Subsection "no_throw_on_crash()"
.Vb 7
\& Title   : no_throw_on_crash
\& Usage   : $fac\->no_throw_on_crash($newval)
\& Function: set to prevent an exeception throw on a failed 
\&           blast program execution
\& Example : 
\& Returns : value of no_throw_on_crash (boolean)
\& Args    : on set, new value (boolean)
.Ve
.SH "Internals"
.IX Header "Internals"
.SS "\fI_fastize()\fP"
.IX Subsection "_fastize()"
.Vb 6
\& Title   : _fastize
\& Usage   : 
\& Function: convert a sequence collection to a temporary
\&           fasta file (sans gaps)
\& Returns : fasta filename (scalar string)
\& Args    : sequence collection
.Ve
.SS "\fI_register_temp_for_cleanup()\fP"
.IX Subsection "_register_temp_for_cleanup()"
.Vb 7
\& Title   : _register_temp_for_cleanup
\& Usage   : 
\& Function: register a file for cleanup with 
\&           cleanup() method
\& Returns : true on success
\& Args    : a file name or a blastdb basename
\&           (scalar string)
.Ve
.SS "\fIcleanup()\fP"
.IX Subsection "cleanup()"
.Vb 5
\& Title   : cleanup
\& Usage   : 
\& Function: unlink files registered for cleanup
\& Returns : true on success
\& Args    :
.Ve
.SS "\s-1AUTOLOAD\s0"
.IX Subsection "AUTOLOAD"
In this module, \f(CW\*(C`AUTOLOAD()\*(C'\fR delegates Bio::Tools::Run::WrapperBase and
Bio::Tools::Run::WrapperBase::CommandExts methods (including those
of Bio::ParamterBaseI) to the \f(CW\*(C`factory()\*(C'\fR attribute:
.PP
.Vb 1
\& $fac\->stderr
.Ve
.PP
gives you
.PP
.Vb 1
\& $fac\->factory\->stderr
.Ve
.PP
If \f(CW$AUTOLOAD\fR isn't pointing to a WrapperBase method, then \s-1AUTOLOAD\s0 attempts to return a \f(CW\*(C`db_info\*(C'\fR attribute: e.g.
.PP
.Vb 1
\& $fac\->db_num_sequences
.Ve
.PP
works by looking in the \f(CW$fac\fR\->\fIdb_info()\fR hash.
.PP
Finally, if \f(CW$AUTOLOAD\fR is pointing to a blast query method, \s-1AUTOLOAD\s0
runs \f(CW\*(C`run\*(C'\fR with the \f(CW\*(C`\-method\*(C'\fR parameter appropriately set.
