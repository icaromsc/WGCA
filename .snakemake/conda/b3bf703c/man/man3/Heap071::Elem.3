.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Heap071::Elem 3"
.TH Heap071::Elem 3 "2015-09-23" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Heap::Elem \- Perl extension for elements to be put in Heaps
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Heap::Elem::SomeInheritor;
\&
\&  use Heap::SomeHeapClass;
\&
\&  $elem = Heap::Elem::SomeInheritor\->new( $value );
\&  $heap = Heap::SomeHeapClass\->new;
\&
\&  $heap\->add($elem);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an inheritable class for Heap Elements.  It provides
the interface documentation and some inheritable methods.
Only a child classes can be used \- this class is not complete.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$elem = Heap::Elem::SomeInheritor\->new( [args] );" 4
.el .IP "\f(CW$elem\fR = Heap::Elem::SomeInheritor\->new( [args] );" 4
.IX Item "$elem = Heap::Elem::SomeInheritor->new( [args] );"
Creates a new Elem.
.ie n .IP "$elem\->heap( $val ); $elem\->heap;" 4
.el .IP "\f(CW$elem\fR\->heap( \f(CW$val\fR ); \f(CW$elem\fR\->heap;" 4
.IX Item "$elem->heap( $val ); $elem->heap;"
Provides a method for use by the Heap processing routines.
If a value argument is provided, it will be saved.  The
new saved value is always returned.  If no value argument
is provided, the old saved value is returned.
.Sp
The Heap processing routines use this method to map an element
into its internal structure.  This is needed to support the
Heap methods that affect elements that are not are the top
of the heap \- \fIdecrease_key\fR and \fIdelete\fR.
.Sp
The Heap processing routines will ensure that this value is
undef when this elem is removed from a heap, and is not undef
after it is inserted into a heap.  This means that you can
check whether an element is currently contained within a heap
or not.  (It cannot be used to determine which heap an element
is contained in, if you have multiple heaps.  Keeping that
information accurate would make the operation of merging two
heaps into a single one take longer \- it would have to traverse
all of the elements in the merged heap to update them; for
Binomial and Fibonacci heaps that would turn an O(1) operation
into an O(n) one.)
.ie n .IP "$elem1\->cmp($elem2)" 4
.el .IP "\f(CW$elem1\fR\->cmp($elem2)" 4
.IX Item "$elem1->cmp($elem2)"
A routine to compare two elements.  It must return a negative
value if this element should go higher on the heap than \fI\f(CI$elem2\fI\fR,
0 if they are equal, or a positive value if this element should
go lower on the heap than \fI\f(CI$elem2\fI\fR.  Just as with sort, the
Perl operators <=> and cmp cause the smaller value to be returned
first; similarly you can negate the meaning to reverse the order
\&\- causing the heap to always return the largest element instead
of the smallest.
.SH "INHERITING"
.IX Header "INHERITING"
This class can be inherited to provide an oject with the
ability to be heaped.  If the object is implemented as
a hash, and if it can deal with a key of \fIheap\fR, leaving
it unchanged for use by the heap routines, then the following
implementation will work.
.PP
.Vb 1
\&  package myObject;
\&
\&  require Exporter;
\&
\&  @ISA = qw(Heap::Elem);
\&
\&  sub new {
\&      my $self = shift;
\&      my $class = ref($self) || $self;
\&
\&      my $self = SUPER::new($class);
\&
\&      # set $self\->{key} = $value;
\&  }
\&
\&  sub cmp {
\&      my $self = shift;
\&      my $other = shift;
\&
\&      $self\->{key} cmp $other\->{key};
\&  }
\&
\&  # other methods for the rest of myObject\*(Aqs functionality
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
John Macdonald, jmm@perlwolf.com
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1998\-2003, O'Reilly & Associates.
.PP
This code is distributed under the same copyright terms as perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIHeap\fR\|(3), \fIHeap::Elem::Num\fR\|(3), \fIHeap::Elem::NumRev\fR\|(3),
\&\fIHeap::Elem::Str\fR\|(3), \fIHeap::Elem::StrRev\fR\|(3).
