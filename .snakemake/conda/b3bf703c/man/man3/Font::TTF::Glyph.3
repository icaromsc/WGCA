.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Font::TTF::Glyph 3"
.TH Font::TTF::Glyph 3 "2016-08-03" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Font::TTF::Glyph \- Holds a information for a single glyph
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a single glyph description as held in a \s-1TT\s0 font. On creation only its
header is read. Thus you can get the bounding box of each glyph without having
to read all the other information.
.SH "INSTANCE VARIABLES"
.IX Header "INSTANCE VARIABLES"
In addition to the named variables in a glyph header (\f(CW\*(C`xMin\*(C'\fR etc.), there are
also all capital instance variables for holding working information, mostly
from the location table.
.SS "Variables for all glyphs:"
.IX Subsection "Variables for all glyphs:"
The standard attributes each glyph has are:
.IP "numberOfContours" 4
.IX Item "numberOfContours"
For simple glyphs this will be the count of contours. For compound glyphs this will be \-1.
.IP "xMin" 4
.IX Item "xMin"
.PD 0
.IP "yMin" 4
.IX Item "yMin"
.IP "xMax" 4
.IX Item "xMax"
.IP "yMax" 4
.IX Item "yMax"
.PD
These identify the bounding box of the glyph.
.PP
There are also other, derived, instance variables for each glyph which are read
when the whole glyph is read (via \f(CW\*(C`read_dat\*(C'\fR):
.IP "instLen" 4
.IX Item "instLen"
Number of bytes in the hinting instructions (Warning this variable is deprecated,
use \f(CW\*(C`length($g\-\*(C'\fR{'hints'})> instead).
.IP "hints" 4
.IX Item "hints"
The string containing the hinting code for the glyph
.SS "Variables for simple glyphs (numberOfContours >= 0):"
.IX Subsection "Variables for simple glyphs (numberOfContours >= 0):"
.IP "endPoints" 4
.IX Item "endPoints"
An array of endpoints for each contour in the glyph. There are
\&\f(CW\*(C`numberOfContours\*(C'\fR contours in a glyph. The number of points in a glyph is
equal to the highest endpoint of a contour.
.IP "numPoints" 4
.IX Item "numPoints"
This is a generated value which contains the total number of points for this simple glyph.
.PP
There are also a number of arrays indexed by point number:
.IP "flags" 4
.IX Item "flags"
The flags associated with reading this point. The flags for a point are
recalculated for a point when it is \f(CW\*(C`update\*(C'\fRd. Thus the flags are not very
useful. The only important bit is bit 0 which indicates whether the point is
an 'on' curve point, or an 'off' curve point.
.IP "x" 4
.IX Item "x"
The absolute x co-ordinate of the point.
.IP "y" 4
.IX Item "y"
The absolute y co-ordinate of the point
.SS "Variables for compound glyphs (numberOfContours == \-1):"
.IX Subsection "Variables for compound glyphs (numberOfContours == -1):"
.IP "metric" 4
.IX Item "metric"
This holds the component number (not its glyph number) of the component from
which the metrics for this glyph should be taken.
.IP "comps" 4
.IX Item "comps"
This is an array of hashes for each component. Each hash has a number of
elements:
.RS 4
.IP "glyph" 4
.IX Item "glyph"
The glyph number of the glyph which comprises this component of the composite.
\&\s-1NOTE:\s0 In some badly generated fonts, \f(CW\*(C`glyph\*(C'\fR may contain a numerical value
but that glyph might not actually exist in the font file.  This could
occur in any glyph, but is particularly likely for glyphs that have
no strokes, such as \s-1SPACE, U+00A0\s0 NO-BREAK \s-1SPACE,\s0 or 
U+200B \s-1ZERO WIDTH SPACE.\s0
.IP "args" 4
.IX Item "args"
An array of two arguments which may be an x, y co-ordinate or two attachment
points (one on the base glyph the other on the component). See flags for details.
.IP "flag" 4
.IX Item "flag"
The flag for this component
.IP "scale" 4
.IX Item "scale"
A 4 number array for component scaling. This allows stretching, rotating, etc.
Note that scaling applies to placement co-ordinates (rather than attachment points)
before locating rather than after.
.RE
.RS 4
.RE
.IP "numPoints" 4
.IX Item "numPoints"
This is a generated value which contains the number of components read in for this
compound glyph.
.SS "Private instance variables:"
.IX Subsection "Private instance variables:"
.IP "\s-1INFILE\s0 (P)" 4
.IX Item "INFILE (P)"
The input file form which to read any information
.IP "\s-1LOC\s0 (P)" 4
.IX Item "LOC (P)"
Location relative to the start of the glyf table in the read file
.IP "\s-1BASE\s0 (P)" 4
.IX Item "BASE (P)"
The location of the glyf table in the read file
.IP "\s-1LEN\s0 (P)" 4
.IX Item "LEN (P)"
This is the number of bytes required by the glyph. It should be kept up to date
by calling the \f(CW\*(C`update\*(C'\fR method whenever any of the glyph content changes.
.IP "\s-1OUTLOC\s0 (P)" 4
.IX Item "OUTLOC (P)"
Location relative to the start of the glyf table. This variable is only active
whilst the output process is going on. It is used to inform the location table
where the glyph is located, since the glyf table is output before the loca
table due to alphabetical ordering.
.IP "\s-1OUTLEN\s0 (P)" 4
.IX Item "OUTLEN (P)"
This indicates the length of the glyph data when it is output. This more
accurately reflects the internal memory form than the \f(CW\*(C`LEN\*(C'\fR variable which
only reflects the read file length. The \f(CW\*(C`OUTLEN\*(C'\fR variable is only set after
calling \f(CW\*(C`out\*(C'\fR or \f(CW\*(C`out_dat\*(C'\fR.
.SS "Editing"
.IX Subsection "Editing"
If you want to edit a glyph in some way, then you should read_dat the glyph, then
make your changes and then update the glyph or set the \f(CW$g\fR\->{' isDirty'} variable.
The application must ensure that the following instance variables are
correct, from which update will calculate the rest, including the bounding box
information.
.PP
.Vb 6
\&    numPoints
\&    numberOfContours
\&    endPoints
\&    x, y, flags         (only flags bit 0)
\&    instLen
\&    hints
.Ve
.PP
For components, the numPoints, x, y, endPoints & flags are not required but
the following information is required for each component.
.PP
.Vb 5
\&    flag                (bits 2, 10, 11, 12)
\&    glyph
\&    args
\&    scale
\&    metric              (glyph instance variable)
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SH "Font::TTF::Glyph\->new(%parms)"
.IX Header "Font::TTF::Glyph->new(%parms)"
Creates a new glyph setting various instance variables
.ie n .SS "$g\->read"
.el .SS "\f(CW$g\fP\->read"
.IX Subsection "$g->read"
Reads the header component of the glyph (numberOfContours and bounding box) and also the
glyph content, but into a data field rather than breaking it down into
its constituent structures. Use read_dat for this.
.ie n .SS "$g\->read_dat"
.el .SS "\f(CW$g\fP\->read_dat"
.IX Subsection "$g->read_dat"
Reads the contents of the glyph (components and curves, etc.) from the memory
store \f(CW\*(C`DAT\*(C'\fR into structures within the object.
.ie n .SS "$g\->out($fh)"
.el .SS "\f(CW$g\fP\->out($fh)"
.IX Subsection "$g->out($fh)"
Writes the glyph data to outfile
.ie n .SS "$g\->out_xml($context, $depth)"
.el .SS "\f(CW$g\fP\->out_xml($context, \f(CW$depth\fP)"
.IX Subsection "$g->out_xml($context, $depth)"
Outputs an \s-1XML\s0 description of the glyph
.ie n .SS "$g\->dirty($val)"
.el .SS "\f(CW$g\fP\->dirty($val)"
.IX Subsection "$g->dirty($val)"
This sets the dirty flag to the given value or 1 if no given value. It returns the
value of the flag
.ie n .SS "$g\->update"
.el .SS "\f(CW$g\fP\->update"
.IX Subsection "$g->update"
Generates a \f(CW\*(C`$self\-\*(C'\fR{'\s-1DAT\s0'}> from the internal structures, if the data has
been read into structures in the first place. If you are building a glyph
from scratch you will need to set the instance variable \f(CW\*(Aq isDirty\*(Aq\fR.
.ie n .SS "$g\->update_bbox"
.el .SS "\f(CW$g\fP\->update_bbox"
.IX Subsection "$g->update_bbox"
Updates the bounding box for this glyph according to the points in the glyph
.ie n .SS "$g\->maxInfo"
.el .SS "\f(CW$g\fP\->maxInfo"
.IX Subsection "$g->maxInfo"
Returns lots of information about a glyph so that the \f(CW\*(C`maxp\*(C'\fR table can update
itself. Returns array containing contributions of this glyph to maxPoints, maxContours, 
maxCompositePoints, maxCompositeContours, maxSizeOfInstructions, maxComponentElements, 
and maxComponentDepth.
.ie n .SS "$g\->empty"
.el .SS "\f(CW$g\fP\->empty"
.IX Subsection "$g->empty"
Empties the glyph of all information to the level of not having been read.
Useful for saving memory in apps with many glyphs being read
.ie n .SS "$g\->get_points"
.el .SS "\f(CW$g\fP\->get_points"
.IX Subsection "$g->get_points"
This method creates point information for a compound glyph. The information is
stored in the same place as if the glyph was not a compound, but since
numberOfContours is negative, the glyph is still marked as being a compound
.ie n .SS "$g\->get_refs"
.el .SS "\f(CW$g\fP\->get_refs"
.IX Subsection "$g->get_refs"
Returns an array of all the glyph ids that are used to make up this glyph. That
is all the compounds and their references and so on. If this glyph is not a
compound, then returns an empty array.
.PP
Please note the warning about bad fonts that reference nonexistent glyphs
under \s-1INSTANCE VARIABLES\s0 above.  This function will not attempt to 
filter out nonexistent glyph numbers.
.SH "BUGS"
.IX Header "BUGS"
.IP "\(bu" 4
The instance variables used here are somewhat clunky and inconsistent with
the other tables.
.IP "\(bu" 4
\&\f(CW\*(C`update\*(C'\fR doesn't re-calculate the bounding box or \f(CW\*(C`numberOfContours\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Martin Hosken <http://scripts.sil.org/FontUtils>.
.SH "LICENSING"
.IX Header "LICENSING"
Copyright (c) 1998\-2016, \s-1SIL\s0 International (http://www.sil.org)
.PP
This module is released under the terms of the Artistic License 2.0. 
For details, see the full text of the license in the file \s-1LICENSE.\s0
